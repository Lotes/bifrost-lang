/******************************************************************************
 * This file was generated by langium-cli 1.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type Addition = BinaryWireTargetExpression | Factor;

export const Addition = 'Addition';

export function isAddition(item: unknown): item is Addition {
    return reflection.isInstance(item, Addition);
}

export type DataType = BooleanConstructor | FloatConstructor | IntegerConstructor | StringConstructor | TypeConstructor;

export const DataType = 'DataType';

export function isDataType(item: unknown): item is DataType {
    return reflection.isInstance(item, DataType);
}

export type Direction = 'in' | 'out';

export type Expression = Addition | BinaryWireTargetExpression;

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export type Factor = BinaryWireTargetExpression | Primary;

export const Factor = 'Factor';

export function isFactor(item: unknown): item is Factor {
    return reflection.isInstance(item, Factor);
}

export type Primary = ConstructorApplication | ForeignInstancePortExpression | MatchVariableDefinition | MatchVariableUsage | NumericLiteral | ParenthesesWireTargetExpression | SelfInstancePortExpression | StringLiteral;

export const Primary = 'Primary';

export function isPrimary(item: unknown): item is Primary {
    return reflection.isInstance(item, Primary);
}

export type ProcessSignatureType = ImplementationDefinition | InterfaceDefinition;

export const ProcessSignatureType = 'ProcessSignatureType';

export function isProcessSignatureType(item: unknown): item is ProcessSignatureType {
    return reflection.isInstance(item, ProcessSignatureType);
}

export type SignatureType = DataTypeDefinition | ProcessSignatureType;

export const SignatureType = 'SignatureType';

export function isSignatureType(item: unknown): item is SignatureType {
    return reflection.isInstance(item, SignatureType);
}

export type TypeExpression = ParenthesesTypeExpression | TypeApplication | TypeParameterReference;

export const TypeExpression = 'TypeExpression';

export function isTypeExpression(item: unknown): item is TypeExpression {
    return reflection.isInstance(item, TypeExpression);
}

export interface BinaryWireTargetExpression extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | ParenthesesWireTargetExpression | PatternMatchDefinition | PatternMatching | WireDefinition;
    readonly $type: 'BinaryWireTargetExpression';
    left: Addition | Factor | Primary
    op: '!=' | '*' | '+' | '-' | '/' | '<' | '<=' | '==' | '>' | '>=' | 'div' | 'mod'
    right: Addition | Factor | Primary
}

export const BinaryWireTargetExpression = 'BinaryWireTargetExpression';

export function isBinaryWireTargetExpression(item: unknown): item is BinaryWireTargetExpression {
    return reflection.isInstance(item, BinaryWireTargetExpression);
}

export interface BooleanConstructor extends AstNode {
    readonly $container: PortDefinition;
    readonly $type: 'BooleanConstructor';
}

export const BooleanConstructor = 'BooleanConstructor';

export function isBooleanConstructor(item: unknown): item is BooleanConstructor {
    return reflection.isInstance(item, BooleanConstructor);
}

export interface ConstructorApplication extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | ParenthesesWireTargetExpression | PatternMatchDefinition | PatternMatching | WireDefinition;
    readonly $type: 'ConstructorApplication';
    arguments: Array<Primary>
    constructor: Reference<DataTypeConstructorDefinition>
}

export const ConstructorApplication = 'ConstructorApplication';

export function isConstructorApplication(item: unknown): item is ConstructorApplication {
    return reflection.isInstance(item, ConstructorApplication);
}

export interface DataTypeConstructorDefinition extends AstNode {
    readonly $container: DataTypeDefinition;
    readonly $type: 'DataTypeConstructorDefinition';
    name: string
    parameters: Array<TypeExpression>
}

export const DataTypeConstructorDefinition = 'DataTypeConstructorDefinition';

export function isDataTypeConstructorDefinition(item: unknown): item is DataTypeConstructorDefinition {
    return reflection.isInstance(item, DataTypeConstructorDefinition);
}

export interface DataTypeDefinition extends AstNode {
    readonly $container: File;
    readonly $type: 'DataTypeDefinition';
    constructors: Array<DataTypeConstructorDefinition>
    name: string
    typeParameters: Array<TypeParameter>
}

export const DataTypeDefinition = 'DataTypeDefinition';

export function isDataTypeDefinition(item: unknown): item is DataTypeDefinition {
    return reflection.isInstance(item, DataTypeDefinition);
}

export interface File extends AstNode {
    readonly $type: 'File';
    dataTypeDefinitions: Array<DataTypeDefinition>
    implementations: Array<ImplementationDefinition>
    interfaces: Array<InterfaceDefinition>
}

export const File = 'File';

export function isFile(item: unknown): item is File {
    return reflection.isInstance(item, File);
}

export interface FloatConstructor extends AstNode {
    readonly $container: PortDefinition;
    readonly $type: 'FloatConstructor';
}

export const FloatConstructor = 'FloatConstructor';

export function isFloatConstructor(item: unknown): item is FloatConstructor {
    return reflection.isInstance(item, FloatConstructor);
}

export interface ForeignInstancePortExpression extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | ParenthesesWireTargetExpression | PatternMatchDefinition | PatternMatching | WireDefinition;
    readonly $type: 'ForeignInstancePortExpression';
    instanceRef: Reference<ModuleInstance>
    portRef: Reference<PortDefinition>
}

export const ForeignInstancePortExpression = 'ForeignInstancePortExpression';

export function isForeignInstancePortExpression(item: unknown): item is ForeignInstancePortExpression {
    return reflection.isInstance(item, ForeignInstancePortExpression);
}

export interface ImplementationBody extends AstNode {
    readonly $container: ImplementationDefinition | PatternMatchDefinition;
    readonly $type: 'ImplementationBody';
    links: Array<WireDefinition>
    matches: Array<PatternMatching>
    modules: Array<ModuleInstance>
}

export const ImplementationBody = 'ImplementationBody';

export function isImplementationBody(item: unknown): item is ImplementationBody {
    return reflection.isInstance(item, ImplementationBody);
}

export interface ImplementationDefinition extends AstNode {
    readonly $container: File;
    readonly $type: 'ImplementationDefinition';
    arguments: Array<TypeExpression>
    body: ImplementationBody
    iface?: Reference<InterfaceDefinition>
    name: string
    ports: Array<PortDefinition>
    typeParameters: Array<TypeParameter>
}

export const ImplementationDefinition = 'ImplementationDefinition';

export function isImplementationDefinition(item: unknown): item is ImplementationDefinition {
    return reflection.isInstance(item, ImplementationDefinition);
}

export interface IntegerConstructor extends AstNode {
    readonly $container: PortDefinition;
    readonly $type: 'IntegerConstructor';
}

export const IntegerConstructor = 'IntegerConstructor';

export function isIntegerConstructor(item: unknown): item is IntegerConstructor {
    return reflection.isInstance(item, IntegerConstructor);
}

export interface InterfaceDefinition extends AstNode {
    readonly $container: File;
    readonly $type: 'InterfaceDefinition';
    name: string
    ports: Array<PortDefinition>
    typeParameters: Array<TypeParameter>
}

export const InterfaceDefinition = 'InterfaceDefinition';

export function isInterfaceDefinition(item: unknown): item is InterfaceDefinition {
    return reflection.isInstance(item, InterfaceDefinition);
}

export interface MatchVariableDefinition extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | ParenthesesWireTargetExpression | PatternMatchDefinition | PatternMatching | WireDefinition;
    readonly $type: 'MatchVariableDefinition';
    name: string
}

export const MatchVariableDefinition = 'MatchVariableDefinition';

export function isMatchVariableDefinition(item: unknown): item is MatchVariableDefinition {
    return reflection.isInstance(item, MatchVariableDefinition);
}

export interface MatchVariableUsage extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | ParenthesesWireTargetExpression | PatternMatchDefinition | PatternMatching | WireDefinition;
    readonly $type: 'MatchVariableUsage';
    variable: Reference<MatchVariableDefinition>
}

export const MatchVariableUsage = 'MatchVariableUsage';

export function isMatchVariableUsage(item: unknown): item is MatchVariableUsage {
    return reflection.isInstance(item, MatchVariableUsage);
}

export interface ModuleInstance extends AstNode {
    readonly $container: ImplementationBody;
    readonly $type: 'ModuleInstance';
    arguments: Array<TypeExpression>
    module: Reference<ImplementationDefinition>
    name: string
}

export const ModuleInstance = 'ModuleInstance';

export function isModuleInstance(item: unknown): item is ModuleInstance {
    return reflection.isInstance(item, ModuleInstance);
}

export interface NumericLiteral extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | ParenthesesWireTargetExpression | PatternMatchDefinition | PatternMatching | WireDefinition;
    readonly $type: 'NumericLiteral';
    number: string
}

export const NumericLiteral = 'NumericLiteral';

export function isNumericLiteral(item: unknown): item is NumericLiteral {
    return reflection.isInstance(item, NumericLiteral);
}

export interface ParenthesesTypeExpression extends AstNode {
    readonly $container: DataTypeConstructorDefinition | ImplementationDefinition | ModuleInstance | ParenthesesTypeExpression | TypeApplication | TypeConstructor;
    readonly $type: 'ParenthesesTypeExpression';
    type: TypeExpression
}

export const ParenthesesTypeExpression = 'ParenthesesTypeExpression';

export function isParenthesesTypeExpression(item: unknown): item is ParenthesesTypeExpression {
    return reflection.isInstance(item, ParenthesesTypeExpression);
}

export interface ParenthesesWireTargetExpression extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | ParenthesesWireTargetExpression | PatternMatchDefinition | PatternMatching | WireDefinition;
    readonly $type: 'ParenthesesWireTargetExpression';
    expression: Expression
}

export const ParenthesesWireTargetExpression = 'ParenthesesWireTargetExpression';

export function isParenthesesWireTargetExpression(item: unknown): item is ParenthesesWireTargetExpression {
    return reflection.isInstance(item, ParenthesesWireTargetExpression);
}

export interface PatternMatchDefinition extends AstNode {
    readonly $container: PatternMatching;
    readonly $type: 'PatternMatchDefinition';
    body: ImplementationBody
    pattern: Expression
}

export const PatternMatchDefinition = 'PatternMatchDefinition';

export function isPatternMatchDefinition(item: unknown): item is PatternMatchDefinition {
    return reflection.isInstance(item, PatternMatchDefinition);
}

export interface PatternMatching extends AstNode {
    readonly $container: ImplementationBody;
    readonly $type: 'PatternMatching';
    matches: Array<PatternMatchDefinition>
    source: Expression
}

export const PatternMatching = 'PatternMatching';

export function isPatternMatching(item: unknown): item is PatternMatching {
    return reflection.isInstance(item, PatternMatching);
}

export interface PortDefinition extends AstNode {
    readonly $container: ImplementationDefinition | InterfaceDefinition;
    readonly $type: 'PortDefinition';
    direction: Direction
    name: string
    type: DataType
}

export const PortDefinition = 'PortDefinition';

export function isPortDefinition(item: unknown): item is PortDefinition {
    return reflection.isInstance(item, PortDefinition);
}

export interface SelfInstancePortExpression extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | ParenthesesWireTargetExpression | PatternMatchDefinition | PatternMatching | WireDefinition;
    readonly $type: 'SelfInstancePortExpression';
    portRef: Reference<PortDefinition>
}

export const SelfInstancePortExpression = 'SelfInstancePortExpression';

export function isSelfInstancePortExpression(item: unknown): item is SelfInstancePortExpression {
    return reflection.isInstance(item, SelfInstancePortExpression);
}

export interface StringConstructor extends AstNode {
    readonly $container: PortDefinition;
    readonly $type: 'StringConstructor';
}

export const StringConstructor = 'StringConstructor';

export function isStringConstructor(item: unknown): item is StringConstructor {
    return reflection.isInstance(item, StringConstructor);
}

export interface StringLiteral extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | ParenthesesWireTargetExpression | PatternMatchDefinition | PatternMatching | WireDefinition;
    readonly $type: 'StringLiteral';
    string: string
}

export const StringLiteral = 'StringLiteral';

export function isStringLiteral(item: unknown): item is StringLiteral {
    return reflection.isInstance(item, StringLiteral);
}

export interface TypeApplication extends AstNode {
    readonly $container: DataTypeConstructorDefinition | ImplementationDefinition | ModuleInstance | ParenthesesTypeExpression | TypeApplication | TypeConstructor;
    readonly $type: 'TypeApplication';
    dataType: Reference<SignatureType>
    typeParameters: Array<TypeExpression>
}

export const TypeApplication = 'TypeApplication';

export function isTypeApplication(item: unknown): item is TypeApplication {
    return reflection.isInstance(item, TypeApplication);
}

export interface TypeConstructor extends AstNode {
    readonly $container: PortDefinition;
    readonly $type: 'TypeConstructor';
    expr: TypeExpression
}

export const TypeConstructor = 'TypeConstructor';

export function isTypeConstructor(item: unknown): item is TypeConstructor {
    return reflection.isInstance(item, TypeConstructor);
}

export interface TypeParameter extends AstNode {
    readonly $container: DataTypeDefinition | ImplementationDefinition | InterfaceDefinition;
    readonly $type: 'TypeParameter';
    name: string
}

export const TypeParameter = 'TypeParameter';

export function isTypeParameter(item: unknown): item is TypeParameter {
    return reflection.isInstance(item, TypeParameter);
}

export interface TypeParameterReference extends AstNode {
    readonly $container: DataTypeConstructorDefinition | ImplementationDefinition | ModuleInstance | ParenthesesTypeExpression | TypeApplication | TypeConstructor;
    readonly $type: 'TypeParameterReference';
    typeParameter: Reference<TypeParameter>
}

export const TypeParameterReference = 'TypeParameterReference';

export function isTypeParameterReference(item: unknown): item is TypeParameterReference {
    return reflection.isInstance(item, TypeParameterReference);
}

export interface WireDefinition extends AstNode {
    readonly $container: ImplementationBody;
    readonly $type: 'WireDefinition';
    source: Expression
    target: Expression
}

export const WireDefinition = 'WireDefinition';

export function isWireDefinition(item: unknown): item is WireDefinition {
    return reflection.isInstance(item, WireDefinition);
}

export interface BifrostAstType {
    Addition: Addition
    BinaryWireTargetExpression: BinaryWireTargetExpression
    BooleanConstructor: BooleanConstructor
    ConstructorApplication: ConstructorApplication
    DataType: DataType
    DataTypeConstructorDefinition: DataTypeConstructorDefinition
    DataTypeDefinition: DataTypeDefinition
    Expression: Expression
    Factor: Factor
    File: File
    FloatConstructor: FloatConstructor
    ForeignInstancePortExpression: ForeignInstancePortExpression
    ImplementationBody: ImplementationBody
    ImplementationDefinition: ImplementationDefinition
    IntegerConstructor: IntegerConstructor
    InterfaceDefinition: InterfaceDefinition
    MatchVariableDefinition: MatchVariableDefinition
    MatchVariableUsage: MatchVariableUsage
    ModuleInstance: ModuleInstance
    NumericLiteral: NumericLiteral
    ParenthesesTypeExpression: ParenthesesTypeExpression
    ParenthesesWireTargetExpression: ParenthesesWireTargetExpression
    PatternMatchDefinition: PatternMatchDefinition
    PatternMatching: PatternMatching
    PortDefinition: PortDefinition
    Primary: Primary
    ProcessSignatureType: ProcessSignatureType
    SelfInstancePortExpression: SelfInstancePortExpression
    SignatureType: SignatureType
    StringConstructor: StringConstructor
    StringLiteral: StringLiteral
    TypeApplication: TypeApplication
    TypeConstructor: TypeConstructor
    TypeExpression: TypeExpression
    TypeParameter: TypeParameter
    TypeParameterReference: TypeParameterReference
    WireDefinition: WireDefinition
}

export class BifrostAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['Addition', 'BinaryWireTargetExpression', 'BooleanConstructor', 'ConstructorApplication', 'DataType', 'DataTypeConstructorDefinition', 'DataTypeDefinition', 'Expression', 'Factor', 'File', 'FloatConstructor', 'ForeignInstancePortExpression', 'ImplementationBody', 'ImplementationDefinition', 'IntegerConstructor', 'InterfaceDefinition', 'MatchVariableDefinition', 'MatchVariableUsage', 'ModuleInstance', 'NumericLiteral', 'ParenthesesTypeExpression', 'ParenthesesWireTargetExpression', 'PatternMatchDefinition', 'PatternMatching', 'PortDefinition', 'Primary', 'ProcessSignatureType', 'SelfInstancePortExpression', 'SignatureType', 'StringConstructor', 'StringLiteral', 'TypeApplication', 'TypeConstructor', 'TypeExpression', 'TypeParameter', 'TypeParameterReference', 'WireDefinition'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case Addition: {
                return this.isSubtype(Expression, supertype);
            }
            case BinaryWireTargetExpression: {
                return this.isSubtype(Addition, supertype) || this.isSubtype(Expression, supertype) || this.isSubtype(Factor, supertype);
            }
            case BooleanConstructor:
            case FloatConstructor:
            case IntegerConstructor:
            case StringConstructor:
            case TypeConstructor: {
                return this.isSubtype(DataType, supertype);
            }
            case ConstructorApplication:
            case ForeignInstancePortExpression:
            case MatchVariableDefinition:
            case MatchVariableUsage:
            case NumericLiteral:
            case ParenthesesWireTargetExpression:
            case SelfInstancePortExpression:
            case StringLiteral: {
                return this.isSubtype(Primary, supertype);
            }
            case DataTypeDefinition:
            case ProcessSignatureType: {
                return this.isSubtype(SignatureType, supertype);
            }
            case Factor: {
                return this.isSubtype(Addition, supertype);
            }
            case ImplementationDefinition:
            case InterfaceDefinition: {
                return this.isSubtype(ProcessSignatureType, supertype);
            }
            case ParenthesesTypeExpression:
            case TypeApplication:
            case TypeParameterReference: {
                return this.isSubtype(TypeExpression, supertype);
            }
            case Primary: {
                return this.isSubtype(Factor, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'ConstructorApplication:constructor': {
                return DataTypeConstructorDefinition;
            }
            case 'ForeignInstancePortExpression:instanceRef': {
                return ModuleInstance;
            }
            case 'ForeignInstancePortExpression:portRef':
            case 'SelfInstancePortExpression:portRef': {
                return PortDefinition;
            }
            case 'ImplementationDefinition:iface': {
                return InterfaceDefinition;
            }
            case 'MatchVariableUsage:variable': {
                return MatchVariableDefinition;
            }
            case 'ModuleInstance:module': {
                return ImplementationDefinition;
            }
            case 'TypeApplication:dataType': {
                return SignatureType;
            }
            case 'TypeParameterReference:typeParameter': {
                return TypeParameter;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'ConstructorApplication': {
                return {
                    name: 'ConstructorApplication',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'DataTypeConstructorDefinition': {
                return {
                    name: 'DataTypeConstructorDefinition',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'DataTypeDefinition': {
                return {
                    name: 'DataTypeDefinition',
                    mandatory: [
                        { name: 'constructors', type: 'array' },
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            case 'File': {
                return {
                    name: 'File',
                    mandatory: [
                        { name: 'dataTypeDefinitions', type: 'array' },
                        { name: 'implementations', type: 'array' },
                        { name: 'interfaces', type: 'array' }
                    ]
                };
            }
            case 'ImplementationBody': {
                return {
                    name: 'ImplementationBody',
                    mandatory: [
                        { name: 'links', type: 'array' },
                        { name: 'matches', type: 'array' },
                        { name: 'modules', type: 'array' }
                    ]
                };
            }
            case 'ImplementationDefinition': {
                return {
                    name: 'ImplementationDefinition',
                    mandatory: [
                        { name: 'arguments', type: 'array' },
                        { name: 'ports', type: 'array' },
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            case 'InterfaceDefinition': {
                return {
                    name: 'InterfaceDefinition',
                    mandatory: [
                        { name: 'ports', type: 'array' },
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            case 'ModuleInstance': {
                return {
                    name: 'ModuleInstance',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'PatternMatching': {
                return {
                    name: 'PatternMatching',
                    mandatory: [
                        { name: 'matches', type: 'array' }
                    ]
                };
            }
            case 'TypeApplication': {
                return {
                    name: 'TypeApplication',
                    mandatory: [
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new BifrostAstReflection();
