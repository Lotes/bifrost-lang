/******************************************************************************
 * This file was generated by langium-cli 1.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type Addition = BinaryWireTargetExpression | Factor;

export const Addition = 'Addition';

export function isAddition(item: unknown): item is Addition {
    return reflection.isInstance(item, Addition);
}

export type DataType = BooleanConstructor | FloatConstructor | IntegerConstructor | StringConstructor | TypeConstructor;

export const DataType = 'DataType';

export function isDataType(item: unknown): item is DataType {
    return reflection.isInstance(item, DataType);
}

export type Direction = 'in' | 'out';

export type Expression = Addition | BinaryWireTargetExpression;

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export type Factor = BinaryWireTargetExpression | Primary;

export const Factor = 'Factor';

export function isFactor(item: unknown): item is Factor {
    return reflection.isInstance(item, Factor);
}

export type InstanceSource = NodePortSource | NodeTypeDefinitionSource | SelfPortSource;

export const InstanceSource = 'InstanceSource';

export function isInstanceSource(item: unknown): item is InstanceSource {
    return reflection.isInstance(item, InstanceSource);
}

export type Primary = ConstructorApplication | MatchVariableDefinition | MatchVariableUsage | NodePortExpression | NumericLiteral | ParenthesesExpression | SelfPortExpression | StringLiteral;

export const Primary = 'Primary';

export function isPrimary(item: unknown): item is Primary {
    return reflection.isInstance(item, Primary);
}

export type SignatureType = DataTypeDefinition | NodeTypeDefinition;

export const SignatureType = 'SignatureType';

export function isSignatureType(item: unknown): item is SignatureType {
    return reflection.isInstance(item, SignatureType);
}

export type TypeExpression = ParenthesesTypeExpression | TypeApplication | TypeParameterReference;

export const TypeExpression = 'TypeExpression';

export function isTypeExpression(item: unknown): item is TypeExpression {
    return reflection.isInstance(item, TypeExpression);
}

export interface BinaryWireTargetExpression extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | LinkDefinition | ParenthesesExpression | PatternMatchDefinition | PatternMatching;
    readonly $type: 'BinaryWireTargetExpression';
    left: Addition | Factor | Primary
    op: '!=' | '*' | '+' | '-' | '/' | '<' | '<=' | '==' | '>' | '>=' | 'div' | 'mod'
    right: Addition | Factor | Primary
}

export const BinaryWireTargetExpression = 'BinaryWireTargetExpression';

export function isBinaryWireTargetExpression(item: unknown): item is BinaryWireTargetExpression {
    return reflection.isInstance(item, BinaryWireTargetExpression);
}

export interface BooleanConstructor extends AstNode {
    readonly $container: PortDefinition;
    readonly $type: 'BooleanConstructor';
}

export const BooleanConstructor = 'BooleanConstructor';

export function isBooleanConstructor(item: unknown): item is BooleanConstructor {
    return reflection.isInstance(item, BooleanConstructor);
}

export interface ConstructorApplication extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | LinkDefinition | ParenthesesExpression | PatternMatchDefinition | PatternMatching;
    readonly $type: 'ConstructorApplication';
    arguments: Array<Primary>
    constructor: Reference<DataTypeConstructorDefinition>
}

export const ConstructorApplication = 'ConstructorApplication';

export function isConstructorApplication(item: unknown): item is ConstructorApplication {
    return reflection.isInstance(item, ConstructorApplication);
}

export interface DataTypeConstructorDefinition extends AstNode {
    readonly $container: DataTypeDefinition;
    readonly $type: 'DataTypeConstructorDefinition';
    name: string
    typeParameters: Array<TypeParameter>
}

export const DataTypeConstructorDefinition = 'DataTypeConstructorDefinition';

export function isDataTypeConstructorDefinition(item: unknown): item is DataTypeConstructorDefinition {
    return reflection.isInstance(item, DataTypeConstructorDefinition);
}

export interface DataTypeDefinition extends AstNode {
    readonly $container: File;
    readonly $type: 'DataTypeDefinition';
    constructors: Array<DataTypeConstructorDefinition>
    name: string
    typeParameters: Array<TypeParameter>
}

export const DataTypeDefinition = 'DataTypeDefinition';

export function isDataTypeDefinition(item: unknown): item is DataTypeDefinition {
    return reflection.isInstance(item, DataTypeDefinition);
}

export interface File extends AstNode {
    readonly $type: 'File';
    dataTypeDefinitions: Array<DataTypeDefinition>
    implementations: Array<NodeTypeDefinition>
}

export const File = 'File';

export function isFile(item: unknown): item is File {
    return reflection.isInstance(item, File);
}

export interface FloatConstructor extends AstNode {
    readonly $container: PortDefinition;
    readonly $type: 'FloatConstructor';
}

export const FloatConstructor = 'FloatConstructor';

export function isFloatConstructor(item: unknown): item is FloatConstructor {
    return reflection.isInstance(item, FloatConstructor);
}

export interface IntegerConstructor extends AstNode {
    readonly $container: PortDefinition;
    readonly $type: 'IntegerConstructor';
}

export const IntegerConstructor = 'IntegerConstructor';

export function isIntegerConstructor(item: unknown): item is IntegerConstructor {
    return reflection.isInstance(item, IntegerConstructor);
}

export interface LinkDefinition extends AstNode {
    readonly $container: NodeTypeBody;
    readonly $type: 'LinkDefinition';
    source: Expression
    target: Expression
}

export const LinkDefinition = 'LinkDefinition';

export function isLinkDefinition(item: unknown): item is LinkDefinition {
    return reflection.isInstance(item, LinkDefinition);
}

export interface MatchVariableDefinition extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | LinkDefinition | ParenthesesExpression | PatternMatchDefinition | PatternMatching;
    readonly $type: 'MatchVariableDefinition';
    name: string
}

export const MatchVariableDefinition = 'MatchVariableDefinition';

export function isMatchVariableDefinition(item: unknown): item is MatchVariableDefinition {
    return reflection.isInstance(item, MatchVariableDefinition);
}

export interface MatchVariableUsage extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | LinkDefinition | ParenthesesExpression | PatternMatchDefinition | PatternMatching;
    readonly $type: 'MatchVariableUsage';
    variable: Reference<MatchVariableDefinition>
}

export const MatchVariableUsage = 'MatchVariableUsage';

export function isMatchVariableUsage(item: unknown): item is MatchVariableUsage {
    return reflection.isInstance(item, MatchVariableUsage);
}

export interface Node extends AstNode {
    readonly $container: NodeTypeBody;
    readonly $type: 'Node';
    name: string
    source: InstanceSource
}

export const Node = 'Node';

export function isNode(item: unknown): item is Node {
    return reflection.isInstance(item, Node);
}

export interface NodePortExpression extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | LinkDefinition | ParenthesesExpression | PatternMatchDefinition | PatternMatching;
    readonly $type: 'NodePortExpression';
    instanceRef: Reference<Node>
    portRef: Reference<PortDefinition>
}

export const NodePortExpression = 'NodePortExpression';

export function isNodePortExpression(item: unknown): item is NodePortExpression {
    return reflection.isInstance(item, NodePortExpression);
}

export interface NodePortSource extends AstNode {
    readonly $container: Node;
    readonly $type: 'NodePortSource';
    instanceRef: Reference<Node>
    portRef: Reference<PortDefinition>
}

export const NodePortSource = 'NodePortSource';

export function isNodePortSource(item: unknown): item is NodePortSource {
    return reflection.isInstance(item, NodePortSource);
}

export interface NodeTypeBody extends AstNode {
    readonly $container: NodeTypeDefinition | PatternMatchDefinition;
    readonly $type: 'NodeTypeBody';
    links: Array<LinkDefinition>
    matches: Array<PatternMatching>
    nodes: Array<Node>
}

export const NodeTypeBody = 'NodeTypeBody';

export function isNodeTypeBody(item: unknown): item is NodeTypeBody {
    return reflection.isInstance(item, NodeTypeBody);
}

export interface NodeTypeDefinition extends AstNode {
    readonly $container: File;
    readonly $type: 'NodeTypeDefinition';
    abstract: boolean
    arguments: Array<TypeExpression>
    body: NodeTypeBody
    iface?: Reference<NodeTypeDefinition>
    name: string
    ports: Array<PortDefinition>
    typeParameters: Array<TypeParameter>
}

export const NodeTypeDefinition = 'NodeTypeDefinition';

export function isNodeTypeDefinition(item: unknown): item is NodeTypeDefinition {
    return reflection.isInstance(item, NodeTypeDefinition);
}

export interface NodeTypeDefinitionSource extends AstNode {
    readonly $container: Node;
    readonly $type: 'NodeTypeDefinitionSource';
    arguments: Array<TypeExpression>
    nodeDef: Reference<NodeTypeDefinition>
}

export const NodeTypeDefinitionSource = 'NodeTypeDefinitionSource';

export function isNodeTypeDefinitionSource(item: unknown): item is NodeTypeDefinitionSource {
    return reflection.isInstance(item, NodeTypeDefinitionSource);
}

export interface NumericLiteral extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | LinkDefinition | ParenthesesExpression | PatternMatchDefinition | PatternMatching;
    readonly $type: 'NumericLiteral';
    number: string
}

export const NumericLiteral = 'NumericLiteral';

export function isNumericLiteral(item: unknown): item is NumericLiteral {
    return reflection.isInstance(item, NumericLiteral);
}

export interface ParenthesesExpression extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | LinkDefinition | ParenthesesExpression | PatternMatchDefinition | PatternMatching;
    readonly $type: 'ParenthesesExpression';
    expression: Expression
}

export const ParenthesesExpression = 'ParenthesesExpression';

export function isParenthesesExpression(item: unknown): item is ParenthesesExpression {
    return reflection.isInstance(item, ParenthesesExpression);
}

export interface ParenthesesTypeExpression extends AstNode {
    readonly $container: NodeTypeDefinition | NodeTypeDefinitionSource | ParenthesesTypeExpression | TypeApplication | TypeConstructor;
    readonly $type: 'ParenthesesTypeExpression';
    type: TypeExpression
}

export const ParenthesesTypeExpression = 'ParenthesesTypeExpression';

export function isParenthesesTypeExpression(item: unknown): item is ParenthesesTypeExpression {
    return reflection.isInstance(item, ParenthesesTypeExpression);
}

export interface PatternMatchDefinition extends AstNode {
    readonly $container: PatternMatching;
    readonly $type: 'PatternMatchDefinition';
    body: NodeTypeBody
    pattern: Expression
}

export const PatternMatchDefinition = 'PatternMatchDefinition';

export function isPatternMatchDefinition(item: unknown): item is PatternMatchDefinition {
    return reflection.isInstance(item, PatternMatchDefinition);
}

export interface PatternMatching extends AstNode {
    readonly $container: NodeTypeBody;
    readonly $type: 'PatternMatching';
    matches: Array<PatternMatchDefinition>
    source: Expression
}

export const PatternMatching = 'PatternMatching';

export function isPatternMatching(item: unknown): item is PatternMatching {
    return reflection.isInstance(item, PatternMatching);
}

export interface PortDefinition extends AstNode {
    readonly $container: NodeTypeDefinition;
    readonly $type: 'PortDefinition';
    direction: Direction
    name: string
    type: DataType
}

export const PortDefinition = 'PortDefinition';

export function isPortDefinition(item: unknown): item is PortDefinition {
    return reflection.isInstance(item, PortDefinition);
}

export interface SelfPortExpression extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | LinkDefinition | ParenthesesExpression | PatternMatchDefinition | PatternMatching;
    readonly $type: 'SelfPortExpression';
    portRef: Reference<PortDefinition>
}

export const SelfPortExpression = 'SelfPortExpression';

export function isSelfPortExpression(item: unknown): item is SelfPortExpression {
    return reflection.isInstance(item, SelfPortExpression);
}

export interface SelfPortSource extends AstNode {
    readonly $container: Node;
    readonly $type: 'SelfPortSource';
    portRef: Reference<PortDefinition>
}

export const SelfPortSource = 'SelfPortSource';

export function isSelfPortSource(item: unknown): item is SelfPortSource {
    return reflection.isInstance(item, SelfPortSource);
}

export interface StringConstructor extends AstNode {
    readonly $container: PortDefinition;
    readonly $type: 'StringConstructor';
}

export const StringConstructor = 'StringConstructor';

export function isStringConstructor(item: unknown): item is StringConstructor {
    return reflection.isInstance(item, StringConstructor);
}

export interface StringLiteral extends AstNode {
    readonly $container: BinaryWireTargetExpression | ConstructorApplication | LinkDefinition | ParenthesesExpression | PatternMatchDefinition | PatternMatching;
    readonly $type: 'StringLiteral';
    string: string
}

export const StringLiteral = 'StringLiteral';

export function isStringLiteral(item: unknown): item is StringLiteral {
    return reflection.isInstance(item, StringLiteral);
}

export interface TypeApplication extends AstNode {
    readonly $container: NodeTypeDefinition | NodeTypeDefinitionSource | ParenthesesTypeExpression | TypeApplication | TypeConstructor;
    readonly $type: 'TypeApplication';
    arguments: Array<TypeExpression>
    dataType: Reference<SignatureType>
}

export const TypeApplication = 'TypeApplication';

export function isTypeApplication(item: unknown): item is TypeApplication {
    return reflection.isInstance(item, TypeApplication);
}

export interface TypeConstructor extends AstNode {
    readonly $container: PortDefinition;
    readonly $type: 'TypeConstructor';
    arguments: Array<TypeExpression>
    constructor: Reference<DataTypeConstructorDefinition>
}

export const TypeConstructor = 'TypeConstructor';

export function isTypeConstructor(item: unknown): item is TypeConstructor {
    return reflection.isInstance(item, TypeConstructor);
}

export interface TypeParameter extends AstNode {
    readonly $container: DataTypeConstructorDefinition | DataTypeDefinition | NodeTypeDefinition;
    readonly $type: 'TypeParameter';
    name: string
}

export const TypeParameter = 'TypeParameter';

export function isTypeParameter(item: unknown): item is TypeParameter {
    return reflection.isInstance(item, TypeParameter);
}

export interface TypeParameterReference extends AstNode {
    readonly $container: NodeTypeDefinition | NodeTypeDefinitionSource | ParenthesesTypeExpression | TypeApplication | TypeConstructor;
    readonly $type: 'TypeParameterReference';
    typeParameter: Reference<TypeParameter>
}

export const TypeParameterReference = 'TypeParameterReference';

export function isTypeParameterReference(item: unknown): item is TypeParameterReference {
    return reflection.isInstance(item, TypeParameterReference);
}

export interface BifrostAstType {
    Addition: Addition
    BinaryWireTargetExpression: BinaryWireTargetExpression
    BooleanConstructor: BooleanConstructor
    ConstructorApplication: ConstructorApplication
    DataType: DataType
    DataTypeConstructorDefinition: DataTypeConstructorDefinition
    DataTypeDefinition: DataTypeDefinition
    Expression: Expression
    Factor: Factor
    File: File
    FloatConstructor: FloatConstructor
    InstanceSource: InstanceSource
    IntegerConstructor: IntegerConstructor
    LinkDefinition: LinkDefinition
    MatchVariableDefinition: MatchVariableDefinition
    MatchVariableUsage: MatchVariableUsage
    Node: Node
    NodePortExpression: NodePortExpression
    NodePortSource: NodePortSource
    NodeTypeBody: NodeTypeBody
    NodeTypeDefinition: NodeTypeDefinition
    NodeTypeDefinitionSource: NodeTypeDefinitionSource
    NumericLiteral: NumericLiteral
    ParenthesesExpression: ParenthesesExpression
    ParenthesesTypeExpression: ParenthesesTypeExpression
    PatternMatchDefinition: PatternMatchDefinition
    PatternMatching: PatternMatching
    PortDefinition: PortDefinition
    Primary: Primary
    SelfPortExpression: SelfPortExpression
    SelfPortSource: SelfPortSource
    SignatureType: SignatureType
    StringConstructor: StringConstructor
    StringLiteral: StringLiteral
    TypeApplication: TypeApplication
    TypeConstructor: TypeConstructor
    TypeExpression: TypeExpression
    TypeParameter: TypeParameter
    TypeParameterReference: TypeParameterReference
}

export class BifrostAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['Addition', 'BinaryWireTargetExpression', 'BooleanConstructor', 'ConstructorApplication', 'DataType', 'DataTypeConstructorDefinition', 'DataTypeDefinition', 'Expression', 'Factor', 'File', 'FloatConstructor', 'InstanceSource', 'IntegerConstructor', 'LinkDefinition', 'MatchVariableDefinition', 'MatchVariableUsage', 'Node', 'NodePortExpression', 'NodePortSource', 'NodeTypeBody', 'NodeTypeDefinition', 'NodeTypeDefinitionSource', 'NumericLiteral', 'ParenthesesExpression', 'ParenthesesTypeExpression', 'PatternMatchDefinition', 'PatternMatching', 'PortDefinition', 'Primary', 'SelfPortExpression', 'SelfPortSource', 'SignatureType', 'StringConstructor', 'StringLiteral', 'TypeApplication', 'TypeConstructor', 'TypeExpression', 'TypeParameter', 'TypeParameterReference'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case Addition: {
                return this.isSubtype(Expression, supertype);
            }
            case BinaryWireTargetExpression: {
                return this.isSubtype(Addition, supertype) || this.isSubtype(Expression, supertype) || this.isSubtype(Factor, supertype);
            }
            case BooleanConstructor:
            case FloatConstructor:
            case IntegerConstructor:
            case StringConstructor:
            case TypeConstructor: {
                return this.isSubtype(DataType, supertype);
            }
            case ConstructorApplication:
            case MatchVariableDefinition:
            case MatchVariableUsage:
            case NodePortExpression:
            case NumericLiteral:
            case ParenthesesExpression:
            case SelfPortExpression:
            case StringLiteral: {
                return this.isSubtype(Primary, supertype);
            }
            case DataTypeDefinition:
            case NodeTypeDefinition: {
                return this.isSubtype(SignatureType, supertype);
            }
            case Factor: {
                return this.isSubtype(Addition, supertype);
            }
            case NodePortSource:
            case NodeTypeDefinitionSource:
            case SelfPortSource: {
                return this.isSubtype(InstanceSource, supertype);
            }
            case ParenthesesTypeExpression:
            case TypeApplication:
            case TypeParameterReference: {
                return this.isSubtype(TypeExpression, supertype);
            }
            case Primary: {
                return this.isSubtype(Factor, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'ConstructorApplication:constructor':
            case 'TypeConstructor:constructor': {
                return DataTypeConstructorDefinition;
            }
            case 'MatchVariableUsage:variable': {
                return MatchVariableDefinition;
            }
            case 'NodePortExpression:instanceRef':
            case 'NodePortSource:instanceRef': {
                return Node;
            }
            case 'NodePortExpression:portRef':
            case 'NodePortSource:portRef':
            case 'SelfPortExpression:portRef':
            case 'SelfPortSource:portRef': {
                return PortDefinition;
            }
            case 'NodeTypeDefinition:iface':
            case 'NodeTypeDefinitionSource:nodeDef': {
                return NodeTypeDefinition;
            }
            case 'TypeApplication:dataType': {
                return SignatureType;
            }
            case 'TypeParameterReference:typeParameter': {
                return TypeParameter;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'ConstructorApplication': {
                return {
                    name: 'ConstructorApplication',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'DataTypeConstructorDefinition': {
                return {
                    name: 'DataTypeConstructorDefinition',
                    mandatory: [
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            case 'DataTypeDefinition': {
                return {
                    name: 'DataTypeDefinition',
                    mandatory: [
                        { name: 'constructors', type: 'array' },
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            case 'File': {
                return {
                    name: 'File',
                    mandatory: [
                        { name: 'dataTypeDefinitions', type: 'array' },
                        { name: 'implementations', type: 'array' }
                    ]
                };
            }
            case 'NodeTypeBody': {
                return {
                    name: 'NodeTypeBody',
                    mandatory: [
                        { name: 'links', type: 'array' },
                        { name: 'matches', type: 'array' },
                        { name: 'nodes', type: 'array' }
                    ]
                };
            }
            case 'NodeTypeDefinition': {
                return {
                    name: 'NodeTypeDefinition',
                    mandatory: [
                        { name: 'abstract', type: 'boolean' },
                        { name: 'arguments', type: 'array' },
                        { name: 'ports', type: 'array' },
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            case 'NodeTypeDefinitionSource': {
                return {
                    name: 'NodeTypeDefinitionSource',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'PatternMatching': {
                return {
                    name: 'PatternMatching',
                    mandatory: [
                        { name: 'matches', type: 'array' }
                    ]
                };
            }
            case 'TypeApplication': {
                return {
                    name: 'TypeApplication',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'TypeConstructor': {
                return {
                    name: 'TypeConstructor',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new BifrostAstReflection();
